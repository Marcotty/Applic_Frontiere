/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package applic_frontieres;

import CONTROLID.ReponseCONTROLID;
import static CONTROLID.ReponseCONTROLID.ACK;
import static CONTROLID.ReponseCONTROLID.FAIL;
import CONTROLID.RequeteCONTROLID;
import static CONTROLID.RequeteCONTROLID.CHECK;
import static CONTROLID.RequeteCONTROLID.IDENTITE;
import static CONTROLID.RequeteCONTROLID.IDENTITE_INFOS;
import static CONTROLID.RequeteCONTROLID.LOGIN;
import static CONTROLID.RequeteCONTROLID.PERMIS;
import static crypto.crypto.getNewCleSecrete;
import database.MyInstruction;
import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.swing.JOptionPane;
import requetereponse.Reponse;

/**
 *
 * @author fredm
 */
public class Applic_Frontieres extends javax.swing.JFrame {

    /**
     * Creates new form Applic_Frontieres
     */
    String name = "";
    String plaque = "";
    private Socket cliSock;
    private String ad;
    private int port;
    SecretKey K1;
    SecretKey K2;
    public Applic_Frontieres() {
        initComponents();
        K1 = getNewCleSecrete();
        K2 = getNewCleSecrete();
    }

    Applic_Frontieres(Socket cSock, String adresse, int p) {
        initComponents();
        cliSock = cSock;
        ad = adresse;
        port = p;
        K1 = getNewCleSecrete();
        K2 = getNewCleSecrete();
        System.out.println("Client Frontiere | Connected");
        Panel_CheckPlaque.setVisible(false);
        Panel_VERIFID.setVisible(false);
        this.pack();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        Panel_Login = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        TF_Username = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        TF_Pass = new javax.swing.JTextField();
        BLogin = new javax.swing.JButton();
        jLabel6 = new javax.swing.JLabel();
        TF_Rep = new javax.swing.JTextField();
        Panel_CheckPlaque = new javax.swing.JPanel();
        TF_Plaque = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        B_Verif = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        Panel_VERIFID = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        BPermis = new javax.swing.JButton();
        BIdentite = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Application Frontieres");

        jLabel3.setText("Login");

        TF_Username.setText("fred");

        jLabel5.setText("Username");

        TF_Pass.setText("azerty");

        BLogin.setText("Login");
        BLogin.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BLoginActionPerformed(evt);
            }
        });

        jLabel6.setText("Password");

        javax.swing.GroupLayout Panel_LoginLayout = new javax.swing.GroupLayout(Panel_Login);
        Panel_Login.setLayout(Panel_LoginLayout);
        Panel_LoginLayout.setHorizontalGroup(
            Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_LoginLayout.createSequentialGroup()
                .addContainerGap(48, Short.MAX_VALUE)
                .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, Panel_LoginLayout.createSequentialGroup()
                        .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel6)
                            .addComponent(jLabel5))
                        .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(Panel_LoginLayout.createSequentialGroup()
                                .addGap(44, 44, 44)
                                .addComponent(jLabel3))
                            .addGroup(Panel_LoginLayout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(TF_Pass, javax.swing.GroupLayout.DEFAULT_SIZE, 133, Short.MAX_VALUE)
                                    .addComponent(TF_Username)))))
                    .addComponent(BLogin, javax.swing.GroupLayout.Alignment.TRAILING))
                .addGap(95, 95, 95))
        );
        Panel_LoginLayout.setVerticalGroup(
            Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_LoginLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(jLabel3)
                .addGap(18, 18, 18)
                .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TF_Username, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5))
                .addGap(18, 18, 18)
                .addGroup(Panel_LoginLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TF_Pass, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addGap(18, 18, 18)
                .addComponent(BLogin)
                .addContainerGap(19, Short.MAX_VALUE))
        );

        TF_Rep.setText("Réponse :");

        TF_Plaque.setText("1-ABC-123");

        jLabel2.setText("Entrez une plaque à vérifier :");

        B_Verif.setText("Vérifier");
        B_Verif.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                B_VerifActionPerformed(evt);
            }
        });

        jLabel4.setText("CONTROLID");

        javax.swing.GroupLayout Panel_CheckPlaqueLayout = new javax.swing.GroupLayout(Panel_CheckPlaque);
        Panel_CheckPlaque.setLayout(Panel_CheckPlaqueLayout);
        Panel_CheckPlaqueLayout.setHorizontalGroup(
            Panel_CheckPlaqueLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_CheckPlaqueLayout.createSequentialGroup()
                .addGroup(Panel_CheckPlaqueLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(Panel_CheckPlaqueLayout.createSequentialGroup()
                        .addGap(28, 28, 28)
                        .addGroup(Panel_CheckPlaqueLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(B_Verif)
                            .addGroup(Panel_CheckPlaqueLayout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(TF_Plaque, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(Panel_CheckPlaqueLayout.createSequentialGroup()
                        .addGap(143, 143, 143)
                        .addComponent(jLabel4)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        Panel_CheckPlaqueLayout.setVerticalGroup(
            Panel_CheckPlaqueLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_CheckPlaqueLayout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addComponent(jLabel4)
                .addGap(18, 18, 18)
                .addGroup(Panel_CheckPlaqueLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(TF_Plaque, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 25, Short.MAX_VALUE)
                .addComponent(B_Verif)
                .addGap(21, 21, 21))
        );

        jLabel7.setText("VERIFID");

        BPermis.setText("Permis");
        BPermis.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BPermisActionPerformed(evt);
            }
        });

        BIdentite.setText("Identité");
        BIdentite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BIdentiteActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout Panel_VERIFIDLayout = new javax.swing.GroupLayout(Panel_VERIFID);
        Panel_VERIFID.setLayout(Panel_VERIFIDLayout);
        Panel_VERIFIDLayout.setHorizontalGroup(
            Panel_VERIFIDLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_VERIFIDLayout.createSequentialGroup()
                .addGap(152, 152, 152)
                .addComponent(jLabel7)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(Panel_VERIFIDLayout.createSequentialGroup()
                .addGap(66, 66, 66)
                .addComponent(BPermis)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(BIdentite)
                .addGap(73, 73, 73))
        );
        Panel_VERIFIDLayout.setVerticalGroup(
            Panel_VERIFIDLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Panel_VERIFIDLayout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addComponent(jLabel7)
                .addGap(18, 18, 18)
                .addGroup(Panel_VERIFIDLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(BPermis)
                    .addComponent(BIdentite))
                .addContainerGap(39, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(TF_Rep, javax.swing.GroupLayout.PREFERRED_SIZE, 332, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(119, 119, 119)
                        .addComponent(jLabel1)))
                .addGap(0, 15, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Panel_Login, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Panel_CheckPlaque, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Panel_VERIFID, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(Panel_Login, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(Panel_CheckPlaque, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Panel_VERIFID, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 32, Short.MAX_VALUE)
                .addComponent(TF_Rep, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void B_VerifActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_B_VerifActionPerformed
        // TODO add your handling code here:
        Verifier();
    }//GEN-LAST:event_B_VerifActionPerformed

    private void BLoginActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BLoginActionPerformed
        // TODO add your handling code here:
        Login();
    }//GEN-LAST:event_BLoginActionPerformed

    private void BPermisActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BPermisActionPerformed
        // TODO add your handling code here:
        Permis();
    }//GEN-LAST:event_BPermisActionPerformed

    private void BIdentiteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BIdentiteActionPerformed
        // TODO add your handling code here:
        Identite();
    }//GEN-LAST:event_BIdentiteActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Applic_Frontieres.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Applic_Frontieres.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Applic_Frontieres.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Applic_Frontieres.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Applic_Frontieres().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton BIdentite;
    private javax.swing.JButton BLogin;
    private javax.swing.JButton BPermis;
    private javax.swing.JButton B_Verif;
    private javax.swing.JPanel Panel_CheckPlaque;
    private javax.swing.JPanel Panel_Login;
    private javax.swing.JPanel Panel_VERIFID;
    private javax.swing.JTextField TF_Pass;
    private javax.swing.JTextField TF_Plaque;
    private javax.swing.JTextField TF_Rep;
    private javax.swing.JTextField TF_Username;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    // End of variables declaration//GEN-END:variables

    private void Permis() {
        try {
            System.out.println("Verification du permis");
            //HMAC init
            Mac hmac = Mac.getInstance("HMAC-MD5", "BC");
            hmac.init(K1);
            System.out.println("Cle secrete K1 : ");
            System.out.println(Arrays.toString(K1.getEncoded()));
            EnvoyerRequeteCONTROLID(cliSock, PERMIS, plaque);
            //hachage du message
            String temp = Integer.toString(PERMIS) + plaque;
            byte[] message = temp.getBytes();
            hmac.update(message);
            byte[] hb = hmac.doFinal();
            System.out.println("HMAC construit a partir de " +Integer.toString(PERMIS) + plaque + " hmac : "+ new String(hb.toString()));
            //envoie du hmac
            DataOutputStream dos = new DataOutputStream(cliSock.getOutputStream());
            dos.writeInt(hb.length);
            dos.write(hb);
            //envoi de la clé secrete K1 chifrée grace a la cle publique du serveur
            //recuperer la cle publique
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream ("cert_keystore.p12"), "azerty".toCharArray());
            Certificate certificate = keyStore.getCertificate("serverKP");
            PublicKey publicKey = certificate.getPublicKey();
            Cipher chiffrement = Cipher.getInstance("RSA", "BC");
            chiffrement.init(Cipher.ENCRYPT_MODE, publicKey);
            
            byte[] cleCryptee = chiffrement.doFinal(K1.getEncoded());
            dos.writeInt(cleCryptee.length);
            dos.write(cleCryptee);
            System.out.println("Clee cryptee envoyee ! ");
            System.out.println(Arrays.toString(cleCryptee));
            
            Reponse rep = RecevoirReponse(cliSock);
            switch(rep.getCode())
            {
                case ACK :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    break;
                }
                case FAIL :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    break;
                }
            } 
            
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | IOException | KeyStoreException | CertificateException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException ex) {
            Logger.getLogger(Applic_Frontieres.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void Identite() {
        System.out.println("Verification de la carte d'identité");
        
        try {
            DataOutputStream dos = new DataOutputStream(cliSock.getOutputStream());

            //HMAC init
            Mac hmac = Mac.getInstance("HMAC-MD5", "BC");
            hmac.init(K1);
            EnvoyerRequeteCONTROLID(cliSock, IDENTITE, "cryptage");
            //envoi de la requete chifree grace a la clé symétrique K2
            Cipher chiffrement2 = Cipher.getInstance("DES/ECB/PKCS5Padding", "BC");
            chiffrement2.init(Cipher.ENCRYPT_MODE, K2);
            byte[] texteClair = plaque.getBytes();
            byte[] textecrypte = chiffrement2.doFinal(texteClair);
            String plaque_cryptee = new String(textecrypte);//new String(chiffrement2.doFinal(plaque.getBytes()));
            //EnvoyerRequeteCONTROLIDChifree(cliSock, IDENTITE_INFOS, plaque_cryptee);
            dos.writeInt(textecrypte.length);
            dos.write(textecrypte);
            System.out.println("plaque_cryptee envoyee : " + plaque_cryptee + "longK2" + K2.getEncoded().length);
            System.out.println("longueur texte : " + plaque_cryptee.length());

            //envoi de la cle K2 cryptee grace a la cle publique
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream ("cert_keystore.p12"), "azerty".toCharArray());
            Certificate certificate = keyStore.getCertificate("serverKP");
            PublicKey publicKey = certificate.getPublicKey();
            
            Cipher chiffrement3 = Cipher.getInstance("RSA", "BC");
            chiffrement3.init(Cipher.ENCRYPT_MODE, publicKey);
            
            byte[] cleCrypteeK2 = chiffrement3.doFinal(K2.getEncoded());
            dos.writeInt(cleCrypteeK2.length);
            dos.write(cleCrypteeK2);
            System.out.println("Clee cryptee K2 envoyee ! ");
            System.out.println(Arrays.toString(cleCrypteeK2));
            //hachage du message
            String temp = Integer.toString(IDENTITE) + textecrypte.toString();
            byte[] message = temp.getBytes();
            hmac.update(message);
            byte[] hb = hmac.doFinal();
            System.out.println("HMAC locac construit a partir de " +Integer.toString(IDENTITE) + textecrypte.toString() + " hmac : "+ new String(hb.toString()));
            System.out.println("temp : " + temp);
            //envoi du hmac
            dos.writeInt(hb.length);
            dos.write(hb);
            //envoi de la clé secrete K1 chifrée grace a la cle publique du serveur
            
            Cipher chiffrement = Cipher.getInstance("RSA", "BC");
            chiffrement.init(Cipher.ENCRYPT_MODE, publicKey);
            
            byte[] cleCryptee = chiffrement.doFinal(K1.getEncoded());
            dos.writeInt(cleCryptee.length);
            dos.write(cleCryptee);
            System.out.println("Clee cryptee K1 envoyee ! ");
            System.out.println(Arrays.toString(cleCryptee));
            
            Reponse rep = RecevoirReponse(cliSock);
            switch(rep.getCode())
            {
                case ACK :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    break;
                }
                case FAIL :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    break;
                }
            } 
            
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | IOException | CertificateException | KeyStoreException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException ex) {
            Logger.getLogger(Applic_Frontieres.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    private void Verifier() {
        System.out.println("CHECK " + TF_Plaque.getText() + " sent.");
        EnvoyerRequeteCONTROLID(cliSock, CHECK, TF_Plaque.getText());
        EnvoyerSignature(cliSock, TF_Plaque.getText());
        Reponse rep = RecevoirReponse(cliSock);
        if(SignatureReponseOK(cliSock, (ReponseCONTROLID) rep))
        {
           switch(rep.getCode())
            {
                case ACK :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    plaque = TF_Plaque.getText();
                    Panel_CheckPlaque.setVisible(false);
                    Panel_VERIFID.setVisible(true);
                    break;
                }
                case FAIL :
                {
                    ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                    TF_Rep.setText(reponse.getChargeUtile());
                    break;
                }
            } 
        }
        
    }
    private Boolean SignatureReponseOK(Socket cSocket, ReponseCONTROLID rep)
    {;
        System.out.println("req : " + rep.getChargeUtile());
        Boolean isCorrect =false;
        try {
            //recuperer la cle publique
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream ("cert_keystore.p12"), "azerty".toCharArray());
            Certificate certificate = keyStore.getCertificate("serverKP");
            PublicKey publicKey = certificate.getPublicKey();
            
            //System.out.println("Cle publique recuperee : " + publicKey.toString());
            //System.out.println("Depuis le certificat : " + certificate.toString());
            //recevoir la signature
            DataInputStream dis = new DataInputStream(new BufferedInputStream(cSocket.getInputStream()));
            int longueur = dis.readInt();
            byte[] signature_rem = new byte[longueur];
            dis.readFully(signature_rem);
            //Verifier la signature
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initVerify(publicKey);
            signature.update(rep.getChargeUtile().getBytes());
            isCorrect = signature.verify(signature_rem);
            if(isCorrect)
            {
             System.out.println("Signature verifiee : OK ");
                return true;   
            }
        } catch (IOException | NoSuchAlgorithmException | CertificateException | InvalidKeyException | SignatureException | KeyStoreException ex) {
            Logger.getLogger(Applic_Frontieres.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println("Signature verifiee : ERREUR ");
        return false;
    }
    private void Login() {
        System.out.println("LOGIN " + TF_Username.getText()+ " sent.");
        EnvoyerRequeteCONTROLID(cliSock, LOGIN, TF_Username.getText());
        EnvoyerPasswordDigest(cliSock, TF_Pass.getText());
        Reponse rep = RecevoirReponse(cliSock);
        
        switch(rep.getCode())
        {
            case ACK :
            {
                System.out.println("LOGIN " + TF_Username.getText()+ " OK");
                ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                TF_Rep.setText(reponse.getChargeUtile());
                name = TF_Username.getText();
                Login_OK();
                break;
            }
            case FAIL :
            {
                System.out.println("LOGIN " + TF_Username.getText()+ " Fail.");
                ReponseCONTROLID reponse = (ReponseCONTROLID) rep;
                TF_Rep.setText(reponse.getChargeUtile());
                break;
            }
        }
    }
    
    private void EnvoyerSignature(Socket cliSock, String chargeUtile) {
        try {
            //Obtenir une clé privee depuis le keystore
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream ("client_keystore.p12"), "azerty".toCharArray());
            PrivateKey privateKey = (PrivateKey) keyStore.getKey("clientKP", "azerty".toCharArray());
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(privateKey);
            signature.update(chargeUtile.getBytes());
            byte[] digitalSignature = signature.sign();
            DataOutputStream dos = new DataOutputStream(cliSock.getOutputStream());
            dos.writeInt(digitalSignature.length);
            dos.write(digitalSignature);
            System.out.println("Signature envoyée : " + digitalSignature.toString());
            
        } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | UnrecoverableKeyException | IOException | InvalidKeyException | SignatureException ex) {
            Logger.getLogger(Applic_Frontieres.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    private void Login_OK() {
        Panel_Login.setVisible(false);
        this.pack();
        Panel_CheckPlaque.setVisible(true);
        this.pack();
        
        
    }
    public void EnvoyerPasswordDigest(Socket cliSocket, String password)
    {
        try
        {
            MessageDigest md = MessageDigest.getInstance("SHA-1", "BC");
            md.update(password.getBytes());
            
            double aleatoire = Math.random();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            DataOutputStream bdos = new DataOutputStream(baos);
            bdos.writeDouble(aleatoire);
            //System.out.println("aleatoire : " + aleatoire);
            md.update(baos.toByteArray());
            byte[] msgDigest = md.digest();
            
            DataOutputStream dos = new DataOutputStream(cliSock.getOutputStream());
            //System.out.println("Long : " + msgDigest.length);
            dos.writeDouble(aleatoire);
            dos.writeInt(msgDigest.length);
            dos.write(msgDigest);
        }
        catch(NoSuchAlgorithmException | NoSuchProviderException | IOException e)
        {
            System.out.println("Erreur envoi digest : " + e.getClass() + e.getMessage());
        }
    }
    public void EnvoyerRequeteCONTROLIDChifree(Socket cliSocket, int code, String chargeUtile)
    {
        TF_Rep.setText("Requête envoyée.");
        ObjectOutputStream oos;
        RequeteCONTROLID req = null;
        req = new RequeteCONTROLID(code, chargeUtile);
        try
        {
            oos = new ObjectOutputStream(cliSocket.getOutputStream());
            oos.writeObject(req);
        }
        catch (IOException e)
        { System.err.println("Erreur réseau ? [" + e.getMessage() + "]"); }
    }
    public void EnvoyerRequeteCONTROLID(Socket cliSocket, int code, String chargeUtile)
    {
        TF_Rep.setText("Requête envoyée.");
        ObjectOutputStream oos;
        RequeteCONTROLID req = null;
        req = new RequeteCONTROLID(code, chargeUtile);
        try
        {
            oos = new ObjectOutputStream(cliSocket.getOutputStream());
            oos.writeObject(req);
        }
        catch (IOException e)
        { System.err.println("Erreur réseau ? [" + e.getMessage() + "]"); }
    }

    private Reponse RecevoirReponse(Socket cliSock) {
        Reponse rep = null;
        TF_Rep.setText("Attente de la réponse.");
        System.out.println("Attente reponse");
        try
        {
            ObjectInputStream ois = new ObjectInputStream(cliSock.getInputStream());
            rep = (Reponse)ois.readObject();
        }
        catch (ClassNotFoundException e)
        { System.out.println("--- erreur sur la classe = " + e.getMessage()); }
        catch (IOException e)
        { System.out.println("--- erreur IO = " + e.getMessage()); }
        return rep;
    }
}
